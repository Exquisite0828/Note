# 1. MTU与MSS

### MTU（Maximum Transmission Unit）最大传输单元

- **定义**：数据链路层一次能够传输的最大数据包大小
- **层次**：工作在数据链路层（第2层）   但在网络层将数据包封装成MTU
- **包含内容**：整个IP数据包（TCP头部+IP头部 + 应用层数据部分）
- **常见值**：以太网MTU通常为1500字节

### MSS（Maximum Segment Size）最大段大小

- **定义**：TCP层一次能够传输的最大数据段大小
- **层次**：工作在传输层（第4层）
- **包含内容**：仅指应用层数据部分，不包括TCP头部和IP头部
- **计算方式**：MSS = MTU - IP头部长度 - TCP头部长度

### 关系示例

```
MTU = 1500字节（以太网标准）
IP头部 = 20字节（无选项时）
TCP头部 = 20字节（无选项时）
MSS = 1500 - 20 - 20 = 1460字节
```

**一个简单的比喻：**

- **MTU** 就像是公路上对货车整体尺寸的限制（例如，长、宽、高都不能超过某个值）。
- **MSS** 则是货车车厢内部可以装载货物的最大体积。为了让货车能顺利上路，装载的货物（MSS）加上车头和车身等（IP 和 TCP 头部）的尺寸，不能超过公路的限制（MTU）。

### 为什么要有 MTU 和 MSS？

**为什么需要 MTU？**

 **MTU 的存在主要是为了平衡传输效率和网络延迟：**

- **避免无限大的数据包**：网络中的设备（如路由器、交换机）需要缓存和转发数据包，如果数据包无限大，对设备的内存和处理能力要求会极高，成本也会随之增加。

- 平衡效率和延迟：

  - **较大的 MTU**：可以减少头部开销的比例，因为每个数据包都需要添加头部信息，数据包越大，有效数据的占比就越高，传输效率也就越高。
  - **较小的 MTU**：可以减少网络延迟。在共享网络中，一个大的数据包会长时间占用链路，导致其他数据包等待，从而增加整体延迟。 此外，数据包越大，在传输过程中出错的概率也越高，一旦出错就需要重传整个大数据包，代价更大。

- **历史原因**：以太网的 MTU 设置为 1500 字节是一个历史遗留问题，与早期的 CSMA/CD (载波侦听多路访问/冲突检测) 机制有关，旨在确保网络中的冲突能够被有效检测。

**为什么在有了 MTU 之后还需要 MSS？** 既然 网络层可以根据 MTU 对过大的数据包进行分片，为什么 TCP 层还需要一个 MSS 呢？

主要原因是为了**尽可能避免在网络层进行分片**，从而提高传输效率和可靠性。

**举例：**

假设没有MSS，在应用层共有1w4字节的数据需要传输，向下经过传输层传到网络层后，网络层收到该数据包（TCP头部+IP头部+应用层数据共14040字节），发现超过了MTU的大小，就将数据包进行分片（网络层分片**效率低下**），分成10片，然后传输，如果其中任意一个分片丢失了，就会将整个数据包全部重传。

在发送端：如果有MSS，在传输层就会将1W4字节的数据，分成10个TCP段，并给这十个段都加一个TCP头部，之后将这十个段向下传给网络层，此时网络层收到数据包（MSS令其最大1500字节）之后，不需要进行分片，加上IP头部后发给数据链路层，每个包**独立传输**。

在接收端：网络层收到十个数据包之后，对每个数据包独立检查错误，解封装后变为TCP段发给传输层，传输层利用TCP头部的**序列号**将这些段**按正确的顺序重新组装**成原始的应用程序数据流。如果有段丢失，TCP会请求重传那个特定的段。组装完成后将完整的数据上传给应用层。

- **IP 分片的效率问题**：IP 层分片对网络是透明的，但它存在一个严重缺陷：如果分片后的任何一个小数据包在传输过程中丢失，整个原始数据包就必须全部重传。 这会大大增加网络开销和延迟。
- **MSS 的主动控制**：通过在 TCP 层设置 MSS，发送方在发送数据之前，就会主动将数据分割成小于 MSS 的段。 这样一来，每个 TCP 段封装成 IP 包后，其大小就不会超过 MTU，从而避免了在 IP 层进行分片。
- **TCP 的高效重传机制**：如果某个 TCP 段在传输中丢失，TCP 的可靠传输机制只需要重传丢失的那个小段即可，而不需要重传整个大数据块，这比 IP 分片丢失后的重传效率高得多。

**总结来说**，MTU 是数据链路层的一个物理限制，而 MSS 是 TCP 层为了适应这个限制而进行的一种主动优化策略。 通过 MSS 协商，TCP 协议可以主动将数据分割成合适的大小，以避免低效的 IP 层分片，从而在保证数据可靠性的同时，最大化地提升网络传输的效率。







# 2. 用户之间收发信息的过程

## CS模式下的通信机制

整个过程，发送方不需要知道接受方的端口号和IP地址，只需要知道服务器的端口号和IP地址（域名）即可

全靠服务器转发给接收方

### 发送方（同学A）的视角

```
同学A发送文件时：
- 只知道：微信服务器的地址（如 wechat.qq.com:443）
- 不知道：同学B的IP地址、端口号、甚至B在哪个网络
- 只需要：告诉服务器"我要给用户B发文件"
```

### 服务器的转发机制

```
微信服务器维护的信息：
用户A：IP=203.0.113.10, 端口=12345, 在线状态=在线
用户B：IP=198.51.100.20, 端口=54321, 在线状态=在线
用户C：IP=192.168.1.100, 端口=23456, 在线状态=离线
```

### 完整的转发过程

#### 1. A发送给服务器

```
A → 服务器的数据包：
源IP: A的IP地址
目标IP: 微信服务器IP
应用层数据: {
    from: "用户A",
    to: "用户B", 
    type: "文件",
    content: 文件数据
}
```

#### 2. 服务器处理和转发

```
服务器收到后：
1. 解析：这是A发给B的文件
2. 查表：B当前的连接信息是 198.51.100.20:54321
3. 转发：将文件数据推送给B
```

#### 3. 服务器发送给B

```
服务器 → B的数据包：
源IP: 微信服务器IP
目标IP: B的IP地址
应用层数据: {
    from: "用户A",
    to: "用户B",
    type: "文件", 
    content: 文件数据
}
```

## 关键优势

### 1. 简化客户端逻辑

```
客户端只需要：
- 连接到服务器
- 发送"给谁发什么"
- 不用管对方在哪里、怎么到达
```

### 2. 解决网络复杂性

```
服务器处理：
- NAT穿透问题
- 用户离线消息存储
- 跨网络路由
- 负载均衡
```

### 3. 实际例子对比

**微信聊天（CS模式）**：

```
你发消息 → 微信服务器 → 对方收到
你不需要知道对方的IP地址
```

**直接P2P聊天**：

```
你发消息 → 直接到对方
但你必须先知道对方的IP:端口
```

## 这就解释了为什么

1. **微信可以给离线用户发消息**：服务器存储转发
2. **不需要知道对方网络信息**：服务器负责寻址
3. **可以跨不同网络通信**：服务器作为中继
4. **群聊很容易实现**：服务器向多个用户转发

**CS模式下，客户端之间不直接通信，完全依靠服务器的"邮局"功能进行消息转发**。这大大简化了客户端的复杂度，但代价是对服务器的完全依赖。



# 3. 获取目标IP地址的方法

在网络数据发送过程中，网络层本身并不主动“发现”目标IP地址，而是从更高层（通常是应用层或传输层）接收这个地址。以下是网络通信中获取目标IP地址的几种常见方法：

### 1. 域名系统 (DNS) 解析

这是最常见的方法，尤其是在访问网站或连接到远程服务器时。整个过程通常如下：

- **用户输入域名**: 用户在浏览器中输入一个网址，例如 `www.google.com`。这个域名对人类友好，但计算机网络需要IP地址来进行通信。
- **发起DNS查询**: 用户的操作系统会将这个域名发送给一个DNS解析器（通常由互联网服务提供商ISP提供）。
- **解析过程**: DNS解析器会查询一系列的DNS服务器（根服务器、顶级域服务器和权威名称服务器），以找到与该域名对应的IP地址。
- **返回IP地址**: 权威DNS服务器最终会将IP地址（例如 `172.217.160.100`）返回给用户的计算机。
- **向下层传递**: 应用程序（如浏览器）获得IP地址后，在准备发送数据时，会将此IP地址连同数据一起传递给传输层，再由传输层传递给网络层。 网络层随后将这个IP地址放入IP数据包的目标地址字段中。

### 2. 静态配置或直接输入

在某些情况下，IP地址是预先知道的，不需要通过DNS解析：

- **直接输入IP**: 用户可以直接在应用程序中输入数字IP地址来代替域名。
- **配置文件**: 应用程序或操作系统可能有一个配置文件，其中静态地指定了要连接的目标服务器的IP地址。这在企业内部网络或特定软件中很常见。

### 3. 从应用程序和服务中获取

许多应用程序在内部处理IP地址的获取过程：

- **API调用**: 程序员在编写网络应用程序时，会使用套接字（Socket）API。在建立连接（如使用 `connect()` 函数）或发送数据包（如使用 `sendto()` 函数）时，目标IP地址会作为一个参数明确地提供给操作系统内核中的网络协议栈。
- **服务发现**: 在复杂的分布式系统中，服务可能会向一个中心目录注册自己的IP地址，其他服务在需要通信时会从该目录查询IP地址。

### 需要澄清的概念：ARP协议

地址解析协议（ARP）经常被提及，但它的作用**不是**获取目标IP地址。ARP的功能恰恰相反：当网络层已经知道了一个IP地址，并且需要将数据包发送到同一局域网内的该IP地址时，它会使用ARP来查询与该IP地址对应的物理硬件地址（MAC地址）。 如果目标IP地址不在同一局域网内，网络层则会使用ARP来查找下一跳路由器（网关）的MAC地址。

总结来说，网络层在发送数据包之前，必须从上层协议（如TCP或UDP）获得明确的目标IP地址。而这个IP地址最常见的来源是通过DNS将用户友好的域名转换而来，或是由用户或应用程序直接提供。



# 4. 键入网址到网页显示，期间发生了什么？

## 4.1 浏览器解析URL

<img src="./assets/image-20250913161416731.png" alt="image-20250913161416731" style="zoom: 50%;" />

长长的URL实际上是在请求服务器中的**文件资源**(根据路径名)

当没有路径名时，就会访问根目录下事先设置的默认文件，也就是/index.html

## 4.2 根据URL提供的Web服务器和文件名，生成HTTP请求消息

## 4.3 根据域名通过DNS查询IP地址

此时浏览器解析URL已经生成了HTTP消息，需要把消息发送给Web服务器

此时通过DNS将域名转化为IP地址

如：www.server.com.

域名中越靠右的位置，代表层级越高。**.根域**是在最顶层（**根DNS服务器**），下一层就是.com**顶级域DNS服务器**，再下面是server.com**权威DNS服务器**

根域的DNS服务器信息保存在互联网所有的DNS服务器中，客户端只需要找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，再一路找到目标DNS服务器

### 4.3.1 域名解析的工作流程

1. 客户端发出一个DNS请求，问www.server.com的IP是什么，并发给本地DNS服务器（TCP/IP设置中填写的）
2. 本地域名服务器收到请求后，如果缓存里的表格能找到该域名，则直接返回IP地址给客户端。如果没有，本地DNS回去问它的根域名服务器
3. 根DNS收到来自本地NDS请求后，发现www.server.com域名后置是.com，就把.com顶级域名服务器地址发送给本地DNS
4. 本地DNS收到顶级域名服务器地址后，发起请求问www.server.com的IP地址
5. 顶级域名服务器给本地DNS发送负责www.server.com区域的权威DNS服务器的地址(如:dns1.server.com)
6. 本地DNS收到权威DNS服务器地址之后，询问www.server.com对应的IP是什么
7. 权威DNS服务器查询域名后，将对应的IP地址发送给本地DNS
8. 本地DNS将IP返回客户端，客户端和目标建立连接



当然，也不是每次域名解析都需要这么多流程

1. 如果浏览器有该域名缓存
2. 操作系统有该域名缓存
3. hosts文件有该域名缓存

会直接返回，这些条件都不满足才会去问本地DNS服务器

## 4.4 协议栈

通过DNS拿到IP地址之后，就可以把HTTP的传输工作交给操作系统中的协议栈

<img src="./assets/image-20250914201211666.png" alt="image-20250914201211666" style="zoom: 50%;" />

此时数据包可以交给TCP处理



## 4.5. TCP协议—可靠传输

### 4.5.1 TCP报文头部格式

<img src="./assets/image-20250913172323877.png" alt="image-20250913172323877" style="zoom: 50%;" />

1. 源端口号16bit
2. 目标端口号16bit
3. 序号32bit，解决包乱序的问题
4. 确认序列32bit，目的是确认发出去对方是否收到，如果没有收到就应该重新发送，解决丢包问题
5. 状态位6bit，SYN（sync同步）是要发起一个连接，ACK是回复，RST是重新连接，FIN是结束连接等。TCP是面向连接的，所以要用这些去维护连接的状态
6. 窗口大小16bit，TCP要做流量控制，通信双方各声明一个窗口（缓存大小），标识自己当前的处理能力，防止对方发送过快或过慢
7. 拥塞控制，只能做的就是控制自己发送的速度

### 4.5.2 TCP三次握手

TCP连接的建立，称为三次握手。

**每一个数据包（SYN， SYN-ACK， ACK）都需要独立地、完整地走完从源到目的地的整个网络路径。**

所谓连接，只是双方计算机中维护一个状态机，连接建立的过程中，状态变化时序图如下

<img src="./assets/image-20250913174655303.png" alt="image-20250913174655303" style="zoom: 33%;" />

1. 一开始，客户端和服务器都处于`CLOSED`状态。先是服务器主动监听某个端口，处于`LISTEN`状态。
2. 随后客户端主动发起连接`SYN`，之后处于`SYN-SENT`状态，假设Seq Num = x，SYN bit = 1
3. 服务端收到发起的连接，返回SYN，并且ACK = x+1 回应客户端的SYN，发送自己的Seq Num=y 之后处于`SYN_RCVD`状态
4. 客户端收到服务端发送的SYN和ACK之后，发送对SYN确认的ACK=y+1，之后处于`ESTABLISHED`状态

三次握手的目的是保证双方都有发送和接收的能力



### 4.5.3 TCP分割数据

如果HTTP请求消息比较长，超过了MSS的长度，此时TCP就需要把HTTP的数据拆解成一块块数据发送。

![image-20250914091830796](./assets/image-20250914091830796.png)

MTU：一个网络包的最大长度，以太网中一般为1500字节

MSS：出去IP头部(一般20字节)和TCP头部(一般20字节)之后，一个网络包能容纳的TCP数据最大长度

数据会被以MSS的长度为单位进行拆分，拆出来的每一块数据都会被放进单独的网络包中。每个被拆分的数据都会加上TCP头部。

![image-20250914092206953](./assets/image-20250914092206953.png)



## 4.6. IP模块—远程定位

目标IP地址是前面通过DNS获取的

### 4.6.1 IP报文头格式

![image-20250914092824494](./assets/image-20250914092824494.png)

1. Ver: 版本号 占4bit 如： IPv4 0100
2. Head.len 首部的长度，占4bit，以4B为单位（系数） 最大可表示的首部长度为60B（15*4B）。最常用的首部长度是20B（5*4B）该字段的值是0101，此时不使用任何可选字段
3. Type of service 服务类型 ： 占8个bit 代表数据报携带的载荷的类型
4. Length 数据报总长度：占16bit，指首部与数据之和的长度，单位是字节，因此IP数据报的最大长度是2^16^-1=65535B。以太网帧的最大传送单元（MTU）为1500B，因此当一个IP数据报封装成帧时，数据报的总长度（首部+数据）不能超过链路层MTU的值
5. 16-bit identifier 标识：16bit 是一个计数器，每产生一个数据报就+1，并赋值给标识（identifier）字段。但它不是“序号”，因为IP是无连接服务。当一个数据报的长度超过网络MTU时，必须分片，此时每一个数据报片都复制一次标识号，以便能正确重装成原来的数据报
6. Flags 标志：3bit 标志（flags）字段的最低位是MF，MF=1表示后面还有分片，MF=0表示最后一个分片。标志（flags）字段中间的一位是DF，只有当DF=0时才允许分片。
7. **Fragment offset 片偏移**：13bit，它指出较长的数据报在分片后，某片在原数据报中的相对位置，片偏移以8B为偏移单位。除最后一个分片以外，每个分片的长度一定是8B的整数倍
8. Time to live TTL 生存时间： 占8bit，数据报在网络中可通过的路由器数的最大值，标识数据报在网络中的寿命，确保不会无限循环，路由器在转发数据报前，先将TTL-1，若TTL为0，则必须丢弃
9. **Upper layer协议**：8bit，指出此IP数据报携带的数据使用何种协议，即数据报的数据部分应上交给哪个协议进行处理，如TCP,UDP等。值为**6代表TCP**，值为**17代表UDP**
10. Internet checksum 首部校验和： 16bit，他只校验数据报的首部，不包括数据部分，不校验数据部分可减少计算工作量。
11. **Source IP address 原地址字段：32bit 标识发送方IP地址**
12. **Destination IP address 目标地址字段：32bit 标识接收方的IP地址**





## 4.7. MAC地址—两点传输

生成了IP头部之后，接下来网络包还需要在IP头部的前面加上MAC头部。

### 4.7.1 MAC头部信息

MAC头部是以太网使用的头部，它包含了接收方和发送方的MAC地址信息，用于两点之间的传输

<img src="./assets/image-20250914194548655.png" alt="image-20250914194548655" style="zoom: 33%;" />

一般在TCP/IP通信中，MAC包头的协议类型只使用：

1. 0800：IP协议
2. 0806：ARP协议

### 4.7.2 MAC发送方和接收方的确认

发送方的MAC地址获取：MAC地址是在网卡生产时写入到ROM中的，只要将这个值读取出来写入到MAC头部即可

接收方的MAC地址获取：

1. 查路由表，如果在同一网关下，使用ARP协议，在以太网中使用广播的形式询问该IP对应的MAC地址
2. 不在同一网关：通过网关转发给下一跳的路由器一步步到目标

在一次查询后，操作系统会把本次查询结果放到ARP缓存的内存空间中，TTL几分钟









#### 4.7.2.1 子网和网关

同一子网：指IP地址在同一个网络段内，可以直接通信

同一网关：指使用相同的网关设备，但可能在不同的子网中

##### 场景1：同一子网=同一网关



```
设备A: 192.168.1.10/24  网关: 192.168.1.1
设备B: 192.168.1.20/24  网关: 192.168.1.1
┌─────────────┐    ┌─────────────┐
│   设备A     │    │   设备B     │
│192.168.1.10 │    │192.168.1.20 │
└──────┬──────┘    └──────┬──────┘
       │                  │
       └────────┬─────────┘
                │
        ┌───────┴────────┐
        │   交换机/路由器  │
        │  192.168.1.1   │
        └────────────────┘
```

通信方式：A和B直接通信，不需要经过网关

##### 场景2：不同子网+同一网关

```
设备A: 192.168.1.10/24  网关: 192.168.1.1
设备C: 192.168.2.10/24  网关: 192.168.2.1

┌─────────────┐              ┌─────────────┐
│   设备A     │              │   设备C     │
│192.168.1.10 │              │192.168.2.10 │
└──────┬──────┘              └──────┬──────┘
       │                            │
┌──────┴──────┐              ┌──────┴──────┐
│   交换机1    │              │   交换机2    │
└──────┬──────┘              └──────┬──────┘
       │                            │
       └────────┬───────────────────┘
                │
        ┌───────┴────────┐
        │     路由器      │
        │ 192.168.1.1    │
        │ 192.168.2.1    │
        └────────────────┘

```

通信方式：设备A和C必须通过路由器转发，即使连接到同一台路由器

同一网关不同子网的分隔方式：

1. VLAN隔离  三层交换机
2. 路由器+多个二层交换机
3. 软件定义网络SDN



## 4.8 网卡—出口

网络包是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此我们需要将数字信息转换为电信号，才能在网线上传输，这才是**真正的**数据发送过程。负责执行这一操作的是网卡，控制网卡还需要网卡驱动程序

网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和**起始帧分界符**，在末尾加上用于检测错误的**帧校验序列（FCS）**

<img src="./assets/image-20250914202234469.png" alt="image-20250914202234469" style="zoom: 80%;" />

起始帧分界符是一个用来表示包起始位置的标记

末尾的FCS用来检查包传输过程中是否有损坏

最后网卡把包转化为电信号，通过网线发送出去

## 4.9 交换机—送别者

交换机的设计是将网络包原样转发到目的地，交换机工作在MAC层（数据链路层），也成为二层网络设备

通常是需要交给路由器

### 4.9.1 交换机的包接收操作

首先，电信号到达网线接口，交换机里的模块接收，将电信号转换为数字信号

然后使用FCS校验错误，没错误就放到缓冲区（这部分操作和计算机网卡相同）

```
计算机网卡和交换机工作方式不同的地方：

计算机网卡本身具有MAC地址，通过核对收到的包的接受方MAC地址判断是不是发给自己的，如果不是则丢弃
交换机的端口不核对接收方的MAC地址，直接接收所有包并存放到缓冲区中，因此交换机端口不具有MAC地址
```

将包放入缓冲区后，接下来查询这个包的接收方MAC地址是否已经在MAC地址表中有记录了。

```
交换机的MAC地址表主要包含两个信息

1.设备的MAC地址
2.该设备连接在交换机的哪个端口上
```

<img src="./assets/image-20250914203523177.png" alt="image-20250914203523177" style="zoom:67%;" />

**交换机根据MAC地址表查找MAC地址，然后将信号发送到相应端口**



### 4.9.2 交换机找不到指定的MAC地址会怎么样

原因：

1. 该地址的设备还没有向交换机发送过包
2. 这个设备一段时间没有工作导致地址在表中被删除了

在这种情况下，交换机只能把包转发到除了源端口之外的所有端口上，总有一个端口连接了目标设备。

**只有目标主机才会接受包，而其他设备则会忽略这个包**

此外，如果接收方MAC地址是一个广播地址，交换机会将包发送到除了源端口之外的所有窗口



## 4.10 路由器—出境大门

网络包经过交换机到达了路由器，并在此被转发到下一个路由器或者目标设备（**通过查表判断包转发的目标**）

### 4.10.1 路由器和交换机的区别

1. 路由器基于IP设计，是三层网络设备，路由器的各个端口都有IP地址和MAC地址
2. 交换机基于以太网设计，二层网络设备，交换机的端口不具有MAC地址（**交换机只有MAC地址表**）

### 4.10.2 路由器的基本原理

路由器的端口具有MAC地址，因此他能成为以太网的发送方和接收方；同时还具有IP地址

当转发包时，首先路由器端口会接受发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

### 4.10.3 路由器的包接收操作

首先，电信号到达网线接口部分，路由器中的模块会讲电信号转换为数字信号，然后通过包末尾的**FCS**进行错误校验

如果没有出错，则检查MAC头部的**接收方MAC地址**，如果是自己的包，就放到接收缓冲区，否则丢弃



### 4.10.4 查询路由表确定输出端口

完成包接收操作之后，路由器就会**去掉**包的MAC头部

**MAC头部的作用就是将包送达路由器**，其中的接收方MAC地址就是路由器端口的MAC地址。

接下来，路由器会根据MAC头部后方的IP头部中的内容进行包的转发操作

转发操作分为几个阶段，首先是**查询路由表判断转发目标**

![image-20250914221307984](./assets/image-20250914221307984.png)

假设地址为**10.10.1.101**的计算机要向地址为**192.168.1.100**的服务器发送一个包，这个包先到达图中的路由器

判断转发目标的第一步，就是根据包的接收方IP地址查询路由表中的目标地址栏，以找到相匹配的记录

路由匹配：每个条目的子网掩码和**192.168.1.100**做**&与运算**后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。

例如：第二条目的子网掩码**255.255.255.0**与**192.168.1.100**做与运算后，得到的结果是192.168.1.0（这是服务器所在的整个子网，服务器属于该子网的设备），这与第二条目的目标地址192.168.1.0匹配，该第二条目记录就会被作为转发目标

实在找不到匹配路由时，就会选择**默认路由**，路由表中子网掩码为0.0.0.0的记录表示默认路由



### 4.10.5 路由器的发送操作

首先，我们需要根据**路由表的网关列**判断对方的地址

1. 如果网关是一个IP地址，则这个IP地址就是我们要转发到的目标地址，还未抵达终点，还需继续路由器转发
2. 如果网关为空，则IP头部中的接收方IP地址就是要转发到的目标地址，也就是终于找到IP包头里的目标地址了，说明已达到终点。

开始发送：

1. 知道对方的IP地址之后，接下来需要通过ARP协议根据IP地址查询MAC地址，并将查询的结果作为接收方MAC地址。

2. 路由器也有ARP缓存，因此首先会在ARP缓存中查询，如果找不到则发送ARP查询请求。

3. 接下来是发送方MAC地址字段，这里填写输出端口的MAC地址。还有一个以太类型字段，填写**0800**（16进制）表示IP协议。

4. 网络包完成后，接下来会将其转换为电信号通过端口发送出去，和计算机相同。
5. 发送出去的网络包会通过交换机达到下一个路由器。由于接收方MAC地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器
6. 接下来，下一个路由器会将包转发给再下一个路由器，**经过层层转发之后，网络包终于到达服务器的子网，通过交换机根据IP查询MAC地址，最终转发到目的主机**



**源IP和目标IP始终不会变，一直变化的是MAC地址**，因为需要MAC地址在以太网内进行两个设备之间的包传输

**路由基于IP，交换基于MAC**，每一跳的MAC地址都是当前段的下一跳设备，而IP地址始终是最终目标。



## 4.11 服务器与客户端—互相扒皮

数据包终于到达了服务器，服务器开始一层层去掉头部

<img src="./assets/image-20250914225112999.png" alt="image-20250914225112999" style="zoom:50%;" />

1. **数据链路层：**数据报抵达服务器后，服务器会先扒开数据报的MAC头部，查看是否和服务器自己的MAC地址符合，符合就收起来。
2. **网络层：**继续扒开数据包的IP头部，发现IP地址符合，根据IP头中的**协议项**，知道自己的上层其实是**TCP协议**
3. **传输层：**继续扒开TCP的头部，里面有序列号，需要看一看这个序列包是不是我想要的(Seq数)，如果是就放入缓存中然后返回一个ACK，如果不是就丢弃。TCP头部还有端口号，HTTP的服务器正在监听这个端口。
4. **传输层：**于是，服务器自然就知道是HTTP进程想要这个包，于是就将包发给HTTP进程。
5. **应用层：**服务器的HTTP进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在HTTP响应报文里。
6. HTTP响应报文也需要加上TCP,IP,MAC头部，不过这次源地址是服务器IP地址，目的地址是客户端IP地址。
7. 加好头部之后，从网卡出去，交由交换机转发到路由器，路由器把响应数据包发到了下一个路由器，最后发到了客户端的子网，又通过交换机找到了客户端。
8. 客户端收到了响应数据包后，拆除MAC,IP,TCP头部后，把HTTP响应报文交给浏览器去渲染页面，之后就显示出来了。
9. 最后客户端要离开了，向服务器发起了TCP四次挥手，至此双方连接断开









# 5. HTTP基本概念



## 5.1 HTTP是什么

HTTP是超文本传输协议，也就是**HyperText Transfer Protocol**

HTTP是一个用在计算机世界里的**协议**。它使用计算机能够理解的语言，确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）

HTTP是一个**双向协议**，是一个在计算机世界里专门用来在**两点之间传输数据**的约定和规范

超文本：指**超越了普通文本的文本**，是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另一个超文本。

HTML就是最常见的超文本，本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再通过浏览器的解释，呈现给我们的就是一个有文字有画面的网页了

**HTTP是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范**



## 5,2 HTTP常见的状态码

<img src="./assets/image-20250915091409832.png" alt="image-20250915091409832" style="zoom: 50%;" />

**1XX**类状态码属于提示信息，是协议处理的一种中间状态，实际用的比较少

**2XX**类状态码表示服务器**成功处理**了客户端的请求，也是我们最愿意看到的状态

1. **200OK**：是最常见的成功状态码，表示一切正常。如果是非HEAD请求，服务器返回的响应头都会有body数据。
2. **204 No Content**：也是常见的成功状态码，与200OK基本相同，但响应头没有body数据
3. **206 Partial Content**：是应用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部，而是其中一部分，也是服务器成功处理的状态。

**3XX**类状态码表示客户端请求的**资源发生了变动**，需要客户端用新的URL重新发送请求获取资源，也就是**重定向**

1. **301 Moved Permanently** 表示永久重定向，说明请求的资源已经不存在了，需改用新的URL再次访问。
2. **302 Found** 表示临时重定向，说明请求的资源还在，但暂时需要用另一个URL来访问。
3. **304 Not Modified** 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制

301和302都会在响应头里使用字段**Location**知名后续要跳转的URL，浏览器会自动重定向行的URL。

**4XX**类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是**错误码**

1. **400 Bad Request**：表示客户端请求的报文有错误，但只是个笼统的错误。
2. **403 Forbidden** ：表示服务器禁止访问资源，并不是客户端的请求出错
3. **404 Not Found**：表示请求的资源在服务器上不存在或未找到，无法提供给客户端。

**5XX**类状态码表示客户端请求报文正确，但是**服务器处理时内部发送了错误**，属于服务器端的错误码

1. **500 Internal Server Error** ：与400类似，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
2. **501 Not Implemented** ：表示客户端请求的功能还不支持。implement(v. 使生效)
3. **502 Bad Gateway** ：通常是服务器作为网关或代理时返回的错误码，表示服务器本身工作正常，访问后端服务器时发生了错误。
4. **503 Service Unavailable** ：表示当前服务器很忙，暂时无法响应客户端。

## 5.3 HTTP常见字段

常见字段有：Host  Content-Lenth   Connection    Content-Type    Content-Encoding     

### Host

客户端发送请求时，用来指定服务器的域名

<img src="./assets/image-20250915132111230.png" alt="image-20250915132111230" style="zoom:50%;" />

有了**Host**字段，就可以将请求发往同一台服务器上的不同网站。



### Content—Length

服务器在返回数据时，会有Content—Length字段，表明这次回应的数据长度



### Connection

Connection字段最常用于客户端要求服务器使用**HTTP长连接**机制，以便其他请求复用

<img src="./assets/image-20250915133615383.png" alt="image-20250915133615383" style="zoom:50%;" />

HTTP长连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。

HTTP/1.1版本的默认连接都是长连接，但为了兼容老版本的HTTP，需要指定Connection首部字段的值为**Keep-Alive**    Connection：Keep-Alive

开启了HTTP的Keep-Alive机制之后，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或者服务器提出断开连接。



### Content-Type

Content-Type字段用于服务器回应时，告诉客户端，本次回应的数据格式。

![image-20250915141806802](./assets/image-20250915141806802.png)

上面的类型表明，发送的是网页，而且编码是UTF-8

客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。



### Content—Encoding

该字段说明数据的压缩方法，表明服务器返回的数据使用了什么压缩格式

![image-20250915141953233](./assets/image-20250915141953233.png)

上面表示服务器返回的数据采用了gzip的方式压缩，告知客户端需要使用此方式解压

客户端在请求时，用Accept—Encoding字段说明自己可以接受哪些压缩方法。





# 6. GET与POST

## 6.1 GET和POST有什么区别

根据RFC规范，**GET的语义是从服务器获取指定的资源**，这个资源可以是静态的文本、页面、图片视频等。GET请求的参数位置一般是写在URL中，URL规定只能支持ASCII，所以GET请求的参数只允许ASCII字符，而且浏览器对URL长度有限制（HTTP协议本身对URL长度没有规定）

比如，想查看小林coding的文章，浏览器就会发送**GET请求**给服务器，服务器会返回文章的文字和图片资源

<img src="./assets/image-20250915150205200.png" alt="image-20250915150205200" style="zoom:50%;" />

根据RFC规范，**POST的语义是根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式视资源类型而不同。POST请求携带数据的位置一般是写在**报文body**中，body中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对body大小做限制。

比如在文章底部留言后提交，浏览器就会执行**POST请求**，把留言文字放进报文body中，然后拼接好POST请求头，通过TCP发给服务器。

<img src="./assets/image-20250915151143441.png" alt="image-20250915151143441" style="zoom:50%;" />



## 6.2 GET和POST的安全和幂等

安全和幂等的概念：

1. 在HTTP中，所谓的**安全**是指请求方法不会破坏服务器上的资源
2. 所谓**幂等**是指多次执行相同操作，结果是相同的

**GET方法是安全且幂等的**，因为它是**只读**操作，无论操作多少次，服务器上的数据都是安全的，且每次结果是相同的。所以，**可以对GET请求的数据作缓存**，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如Nginx），而且在浏览器中GET请求可以保存为书签。

**POST**方法因为是**新增或提交数据**的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以**浏览器一般不会缓存POST请求**，也不能把POST请求保存为书签。





简单小结：

GET的语义是请求获取指定的资源。**GET方法是安全、幂等、可被缓存的**

POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。**POST不安全，不幂等，不可缓存**



注意，上面是从RFC规范定义的语义来分析的。

实际过程中，开发者不一定会按照RFC规范定义的语义来实现GET和POST方法。

比如：

1. 可以用GET方法实现新增或删除数据的请求，这样实现的GET方法自然就不是安全和幂等。
2. 可以用POST方法实现查询数据的请求，这样实现的POST方法自然就是安全和幂等。



如果**安全**放入概念是指信息是否会被泄漏的话，虽然POST用body传输数据，而GET用URL传输，这样数据会在地址栏被看到，但并不能说POST安全

因为HTTP传输的内容都是明文的，虽然在浏览器地址看不到POST提交的body数据，但是只要抓个包就都能看到了

所以要避免传输过程中数据被窃取，就要使用HTTPS协议，所有HTTP数据都会被加密传输。





# 7. HTTP缓存技术



## 7.1 HTTP缓存实现方式

对于一些具有重复性的HTTP请求，比如每次请求得到的数据都是一样的，我们可以把这对**请求—响应**的数据都**缓存在本地**，那么下次就直接读取本地的数据，不必再通过网络获取服务器的响应了，这样的话HTTP/1.1的性能肯定肉眼可见的提升

所以，避免发送HTTP请求的方法就是通过**缓存技术**，HTTP设计者早在之前就考虑到了这点，因此HTTP协议的头部有不少是针对缓存的字段。

HTTP缓存有两种实现方式，分别是**强制缓存和协商缓存**



## 7.2 强制缓存

强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在浏览器。

<img src="./assets/image-20250915213822657.png" alt="image-20250915213822657" style="zoom: 67%;" />

强缓存是利用下面这两个HTTP响应头部（Response Header）字段实现的，他们都用来表示资源在客户端缓存的有效期：

1. Cache—Control 是一个相对时间
2. Expires 是一个绝对时间

如果HTTP响应头部同时具有这两个字段，**Cache—Control优先级高于Expires**

Cache—Control选项更多一些，设置更加精细，所以建议使用Cache—Control来实现强缓存。

实现流程如下：

1. 当浏览器第一次申请访问服务器资源时，服务器会在返回这个资源的同时，在Response头部加上Cache—Control，Cache—Control中设置了过期时间的大小
2. 浏览器再次请求访问服务器中的资源时，会先**通过请求资源的时间与Cache—control中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器
3. 服务器再次收到请求后，会再次更新Response头部中的Cache—Control。



## 7.3 协商缓存

当我们在浏览器使用开发者工具时，你可能会看到某些请求的响应码是**304**，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以通过缓存的方式被称为协商缓存

<img src="./assets/image-20250915214517146.png" alt="image-20250915214517146" style="zoom: 50%;" />

上图就是一个协商缓存的过程，所以**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。

协商缓存可以基于两种头部来实现：

第一种：请求头部中的**If-Modified-Since**字段与响应头部中的**Last-Modified**字段实现

这两个字段的意思是：

1. 响应头部中的**Last-Modified**：标示这个响应资源的最后修改时间
2. 请求头部中的**If-Modified-Since**：当资源过期了，发现响应头中具有Last-Modified声明，则再次发起请求时，带上Last-Modified的时间，服务器收到请求后发现有If-Modified-Since则与被请求的资源的最后修改时间（Last-Modified）进行对比，如果最后修改时间较新，说明资源被修改了，则返回最新资源，**HTTP 200 OK**；如果最后修改时间较旧，说明资源无新修改，**响应HTTP 304 走缓存**

```http
第二次请求
GET /images/logo.png HTTP/1.1
Host: example.com
If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT

服务器响应：
HTTP/1.1 304 Not Modified

如果时间修改了，返回200 OK 和新的修改时间
```

第二种：请求头部中的 **If-None-Match**字段与响应头部的**Etag**字段

这两个字段的意思是：

1. 响应头部中**Etag**：唯一标识响应资源。
2. 请求头部中的**If-None-Match**：当资源过期时，浏览器发现响应头中有Etag，则再次向服务器发起请求时，会将请求头if-None-Match值设置为Etag的值。服务器收到请求后进行比对，如果资源没有变换返回304，变化了返回200。

```http
第二次请求：
GET /api/user/123 HTTP/1.1
Host: api.example.com
If-None-Match: "abc123def456"

服务器响应
HTTP/1.1 304 Not Modified

Etag基于哈希值生成，如果修改了就返回新的Etag
```



第一种实现方法是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否已被修改，避免由于时间篡改导致的不可靠问题。

如果在第一次请求资源时，服务器返回的HTTP响应头部同时有Etag和Last-Modified字段，那么客户端再下一次请求时，如果带上了Etag和Last-Modified字段信息给服务端，**这时Etag的优先级更高**，也就是服务器端会先判断Etag是否变化，如果Etag有变化就不用判断Last-Modified了，如果Etag没有变化，继续看Last-Modified。

### 7.3.1 Etag优先级更高的原因

1. 在没有修改文件内容情况下，文件的最后修改时间也有可能改变，这会导致客户端认为这文件被改动了，从而重新请求；
2. 可能有些文件是在秒级以内修改的，If-Modified-Since 能检查到的颗粒度是秒级的，使用Etag就能够保证这种需求下，客户端在一秒内能刷新多次
3. 有些服务器不能精确获取文件的最后修改时间



注意，**协商缓存这两个字段都需要配合强制缓存中Cache-Control字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。**

<img src="./assets/image-20250915220127434.png" alt="image-20250915220127434" style="zoom:67%;" />

当使用 ETag 字段实现的协商缓存的过程：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；
- 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：
  - 如果没有过期，则直接使用本地缓存；
  - 如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；
- 服务器再次收到请求后，**会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较**：
  - **如果值相等，则返回 304 Not Modified，不会返回资源**；
  - 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；
- 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。





# 8. HTTP特性

到目前为止，HTTP常见版本有HTTP/1.1，HTTP/2.0，HTTP/3.0，不同版本的 HTTP 特性是不一样的。

## 8.1 HTTP/1.1 的优点

1. 简单

HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。

2. 灵活和易于扩展

HTTP协议中的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有固定死，**允许开发人员自定义和扩充**

同时 HTTP 由于是工作在应用层（ `OSI` 第七层），则它**下层可以随意变化**，比如：

- HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层；
- HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议。

3. 应用广泛和跨平台

互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用遍地开花，同时天然具有**跨平台**的优越性。

## 8.2 HTTP/1.1 缺点

HTTP 协议里有优缺点一体的**双刃剑**，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。

1. 无状态双刃剑

无状态的**好处**，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。

无状态的**坏处**，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。

例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。

这样每操作一次，都要验证信息，这样的购物体验还能愉快吗？别问，问就是**酸爽**！

对于无状态的问题，解法方案有很多种，其中比较简单的方式用 **Cookie** 技术。

`Cookie` 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

<img src="./assets/image-20250916171412860.png" alt="image-20250916171412860" style="zoom:50%;" />

2. 明文传输双刃剑

明文意味着在传输过程中的信息，是可方便阅读的，比如 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。

但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于**信息裸奔**。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那**你号没了**。

3. 不安全

HTTP 比较严重的缺点就是不安全：

- 通信使用明文（不加密），内容可能会被窃听。比如，**账号信息容易泄漏，那你号没了。**
- 不验证通信方的身份，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多，那你钱没了。**
- 无法证明报文的完整性，所以有可能已遭篡改。比如，**网页上植入垃圾广告，视觉污染，眼没了。**

HTTP 的安全问题，可以用 **HTTPS** 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。

##  8.3 HTTP/1.1的性能

HTTP 协议是基于 **TCP/IP**，并且使用了「**请求 - 应答**」的通信模式，所以性能的关键就在这**两点**里。

1. **长连接**

早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。

为了解决上述 TCP 连接问题，HTTP/1.1 提出了**长连接**的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

**持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。**

<img src="./assets/image-20250916171642026.png" alt="image-20250916171642026" style="zoom:50%;" />

当然，如果某个HTTP长连接超过一定时间没有任何数据交互，服务端会主动断开这个连接

**2.管道网络传输**

HTTP/1.1 采用了长连接的方式，这使得管道(pipeline)网络传输成为了可能。

即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**

举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求，如下图：

<img src="./assets/image-20250917164010858.png" alt="image-20250917164010858" style="zoom:50%;" />

但是**服务器必须按照接收请求的顺序发送对这些管道化请求的响应**。

如果服务端在处理 A 请求时，耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。

所以，**HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞**。

**注意!!!**

实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持，所以**后面所有文章讨论 HTTP/1.1 都是建立在没有使用管道化的前提**。大家知道有这个功能，但是没有被使用就行了。

**3.队头阻塞**

「请求 - 应答」的模式加剧了 HTTP 的性能问题。

因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」，好比上班的路上塞车。

<img src="./assets/image-20250917164258859.png" alt="image-20250917164258859" style="zoom:50%;" />

总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。







# 9. HTTP与HTTPS

**HTTPS就是使用各种方法保证了服务器和客户端双方能安全的获取会话密钥**



## 9.1 HTTP与HTTPS的区别

- HTTP 是超文本传输协议，**信息是明文传输**，存在安全风险的问题。**HTTPS 则解决 HTTP 不安全的缺陷**，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。

- HTTP 连接建立相对简单，TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 **SSL/TLS** 的握手过程，才可进入加密报文传输。

- 两者的默认端口不一样，HTTP 默认端口号是 80，**HTTPS 默认端口号是 443**。

- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。



## 9.2 HTTPS解决了HTTP的哪些问题

HTTP 由于是明文传输，所以安全上存在以下三个风险：

- **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。
- **篡改风险**，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
- **冒充风险**，比如冒充淘宝网站，用户钱容易没。

<img src="./assets/image-20250917164703268.png" alt="image-20250917164703268" style="zoom:50%;" />

**HTTPS** 在 HTTP 与 TCP 层之间加入了 `SSL/TLS` 协议，可以很好的解决了上述的风险：

- **信息加密**：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。
- **校验机制**：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。
- **身份证书**：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。

可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。





> HTTPS 是如何解决上面的三个风险的？

- **混合加密**的方式实现信息的**机密性**，解决了窃听的风险。
- **摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
- 将服务器公钥放入到**数字证书**中，解决了冒充的风险。



### 9.2.1混合加密

通过**混合加密**的方式可以保证信息的**机密性**，解决了窃听的风险。

<img src="./assets/image-20250917164932601.png" alt="image-20250917164932601" style="zoom:50%;" />

HTTPS 采用的是**对称加密**和**非对称加密**结合的「混合加密」方式：

- 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
- 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

采用「混合加密」的方式的原因：

- **对称加密**只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- **非对称加密**使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

**加密≠完整性**
 加密只能保证数据的机密性（别人看不懂），但无法保证数据的完整性（数据没有被篡改）。

### 9.2.2 摘要算法+数字签名

为了保证传输的内容不被篡改，我们需要对内容计算出一个「指纹」，然后同内容一起传输给对方。

对方收到后，先是对内容也计算出一个「指纹」，然后跟发送方发送的「指纹」做一个比较，如果「指纹」相同，说明内容没有被篡改，否则就可以判断出内容被篡改了。

那么，在计算机里会**用摘要算法（哈希函数）来计算出内容的哈希值**，也就是内容的「指纹」，这个**哈希值是唯一的，且无法通过哈希值推导出内容**。

<img src="./assets/image-20250918132916143.png" alt="image-20250918132916143" style="zoom: 67%;" />

通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**。

那为了避免这种情况，计算机里会用**非对称加密算法**来解决，共有两个密钥：

- 一个是公钥，这个是可以公开给所有人的；
- 一个是私钥，这个必须由本人管理，不可泄露。

这两个密钥可以**双向加解密**的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容，**但是公钥加密内容，无法使用公钥解密**。

流程的不同，意味着目的也不相同：

- **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
- **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

一般我们不会用非对称加密来加密实际的传输内容，因为非对称加密的计算比较耗费性能的。

所以非对称加密的用途主要在于**通过「私钥加密，公钥解密」的方式，来确认消息的身份**，我们常说的**数字签名算法**，就是用的是这种方式，不过私钥加密内容不是内容本身，而是**对内容的哈希值加密**。

![image-20250918133519750](./assets/image-20250918133519750.png)

私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。

### 9.2.3 数字证书

前面我们知道：

- 可以通过哈希算法来保证消息的完整性；
- 可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；

但是这还远远不够，**还缺少身份验证的环节**，万一公钥是被伪造的呢？



**客户端获取公钥的方法：**

#### 1. 数字证书机制

- 服务器不是直接发送公钥，而是发送**数字证书**
- 数字证书包含：
  - **服务器的公钥**（证书是可信的，公钥就是可信的）
  - 服务器的身份信息（域名、组织等）
  - 证书颁发机构（CA）的数字签名
  - 证书有效期等信息

#### 2. 证书链验证

客户端收到证书后进行多层验证：

**第一层：证书签名验证**

- 使用CA的公钥验证证书上的数字签名
- 确认证书确实是由可信CA颁发的

**第二层：证书链追溯**

- 验证CA证书的合法性
- 一直追溯到根证书颁发机构（Root CA）

**第三层：根证书信任**

- 客户端（浏览器/操作系统）预装了可信根CA的证书
- 形成完整的信任链

![image-20250918211619754](./assets/image-20250918211619754.png)

通过数字证书的方式，保证了服务器公钥的身份，解决了冒充的风险



## 9.3 HTTPS连接建立

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话密钥」（客户端随机数，服务器随机数，公钥发送随机数）
- 双方采用「会话密钥」进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是 TLS 握手阶段。

TLS 的「握手阶段」涉及**四次**通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：[RSA 算法](https://xiaolincoding.com/network/2_http/https_rsa.html) 和 [ECDHE 算法](https://xiaolincoding.com/network/2_http/https_ecdhe.html)。

基于RSA的TLS握手过程

会话密钥

<img src="./assets/image-20250918212515192.png" alt="image-20250918212515192" style="zoom: 80%;" />

TLS 协议建立的详细流程

**1. ClientHello**

首先，由客户端向服务器发起加密通信请求，也就是 `ClientHello` 请求。

在这一步，客户端主要向服务器发送以下信息：

（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。

（2）客户端生产的随机数（`Client Random`），后面用于生成「会话秘钥」条件之一。

（3）客户端支持的密码套件列表，如 RSA 加密算法。

**2. SeverHello**

服务器收到客户端请求后，向客户端发出响应，也就是 `ServerHello`。服务器回应的内容有如下内容：

（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。

（2）服务器生产的随机数（`Server Random`），也是后面用于生产「会话秘钥」条件之一。

（3）确认的密码套件列表，如 RSA 加密算法。

（4）服务器的数字证书。

**3.客户端回应**

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会**从数字证书中取出服务器的公钥**，然后使用它加密报文，向服务器发送如下信息：

（1）一个随机数（`pre-master key`）。该随机数会被服务器公钥加密。

（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。

**服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。

**4. 服务器的最后回应**

服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。

然后，向客户端发送最后的信息：

（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 TLS 的握手阶段全部结束。**接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。**





## 9.4 客户端校验数字证书(CA机构颁发)的流程

![image-20250918213843678](./assets/image-20250918213843678.png)

CA签发证书的过程，如上图左边部分：

- 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
- 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
- 最后将 Certificate Signature 添加在文件证书上，形成数字证书；

客户端校验服务端的数字证书的过程，如上图右边部分：

- 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
- 通常**浏览器和操作系统中集成了 CA 的公钥信息**，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2；
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。



但事实上，证书的验证过程中**还存在一个证书信任链的问题**，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：

![image-20250918214453449](./assets/image-20250918214453449.png)

对于这种三级层级关系的证书的验证过程如下：

- 客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是“GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。
- 请求到证书后发现“GlobalSign Organization Validation CA - SHA256 - G2”证书是由“GlobalSign Root CA”签发的，由于“GlobalSign Root CA”没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证“GlobalSign Organization Validation CA - SHA256 - G2”证书，如果发现验证通过，就认为该中间证书是可信的。
- “GlobalSign Organization Validation CA - SHA256 - G2”证书被信任后，可以使用“GlobalSign Organization Validation CA - SHA256 - G2”证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。

在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后“GlobalSign Root CA”证书信任“GlobalSign Organization Validation CA - SHA256 - G2”证书，而“GlobalSign Organization Validation CA - SHA256 - G2”证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。

**总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。**

<img src="./assets/image-20250918214717461.png" alt="image-20250918214717461" style="zoom:50%;" />

这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：

![image-20250918214758013](./assets/image-20250918214758013.png)

为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？

**这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。**





## 9.5 HTTPS的应用数据是如何保证完整性的

TLS 在实现上分为**握手协议**和**记录协议**两层：

- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
- TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；

TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：

![image-20250918215047810](./assets/image-20250918215047810.png)

具体过程如下：

- 首先，消息被分割成多个较短的片段，然后分别对每个片段进行压缩。

- 接下来，经过压缩的片段会被**加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证**。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。

- 再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。

- 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。

记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。







## 9.6 HTTPS一定安全可靠吗

这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。

<img src="./assets/image-20250918215651742.png" alt="image-20250918215651742" style="zoom: 67%;" />

具体过程如下：

- 客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手；
- 在客户端与中间人进行 TLS 握手过程中，中间人会发送自己的公钥证书给客户端，**客户端验证证书的真伪**，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。
- 在中间人与服务端进行 TLS 握手过程中，服务端会发送从 CA 机构签发的公钥证书给中间人，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。
- 后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。

从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色。那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够“偷看”浏览器与服务端之间的 HTTPS 请求和响应的数据。

但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。

中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。

![image-20250918215740698](./assets/image-20250918215740698.png)

如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。

所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那不能怪 HTTPS，得怪自己手贱。

另外，如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。

这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。

所以，**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**。

### 9.6.1 为什么抓包工具能截取HTTPS数据

很多抓包工具 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致的。

对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理：

1. 中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；
2. 中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；

中间人要拿到私钥只能通过如下方式：

1. 去网站服务端拿到私钥；
2. 去 CA 处拿域名签发私钥；
3. 自己签发受浏览器信任的证书；

不用解释，抓包工具只能使用第三种方式取得中间人的身份。

因此使用抓包工具进行 HTTPS 抓包的时候，抓包工具会生成根证书，导入到客户端系统的 受信任的根证书列表 中，这里的根证书实际上起认证中心（CA）的作用。  

随后抓包工具使用该根证书签发域名的证书，因为根证书受信任，域名的证书同样会被浏览器信任。也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人（抓包工具）签发的证书去中间人（抓包工具）自己的 CA 做认证，这个证书当然被认为是有效的。  

### 9.6.2 如何避免被中间人抓取数据

我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。

当然，我们还可以通过 **HTTPS 双向认证**来避免这种问题。

一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。

![image-20250918215955122](./assets/image-20250918215955122.png)

如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。



# 10. HTTP/1.1  HTTP/2  HTTP/3的演变
