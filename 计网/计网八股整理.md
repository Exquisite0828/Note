# 1. MTU与MSS

### MTU（Maximum Transmission Unit）最大传输单元

- **定义**：数据链路层一次能够传输的最大数据包大小
- **层次**：工作在数据链路层（第2层）   但在网络层将数据包封装成MTU
- **包含内容**：整个IP数据包（TCP头部+IP头部 + 应用层数据部分）
- **常见值**：以太网MTU通常为1500字节

### MSS（Maximum Segment Size）最大段大小

- **定义**：TCP层一次能够传输的最大数据段大小
- **层次**：工作在传输层（第4层）
- **包含内容**：仅指应用层数据部分，不包括TCP头部和IP头部
- **计算方式**：MSS = MTU - IP头部长度 - TCP头部长度

### 关系示例

```
MTU = 1500字节（以太网标准）
IP头部 = 20字节（无选项时）
TCP头部 = 20字节（无选项时）
MSS = 1500 - 20 - 20 = 1460字节
```

**一个简单的比喻：**

- **MTU** 就像是公路上对货车整体尺寸的限制（例如，长、宽、高都不能超过某个值）。
- **MSS** 则是货车车厢内部可以装载货物的最大体积。为了让货车能顺利上路，装载的货物（MSS）加上车头和车身等（IP 和 TCP 头部）的尺寸，不能超过公路的限制（MTU）。

### 为什么要有 MTU 和 MSS？

**为什么需要 MTU？**

 **MTU 的存在主要是为了平衡传输效率和网络延迟：**

- **避免无限大的数据包**：网络中的设备（如路由器、交换机）需要缓存和转发数据包，如果数据包无限大，对设备的内存和处理能力要求会极高，成本也会随之增加。

- 平衡效率和延迟：

  - **较大的 MTU**：可以减少头部开销的比例，因为每个数据包都需要添加头部信息，数据包越大，有效数据的占比就越高，传输效率也就越高。
  - **较小的 MTU**：可以减少网络延迟。在共享网络中，一个大的数据包会长时间占用链路，导致其他数据包等待，从而增加整体延迟。 此外，数据包越大，在传输过程中出错的概率也越高，一旦出错就需要重传整个大数据包，代价更大。
  
- **历史原因**：以太网的 MTU 设置为 1500 字节是一个历史遗留问题，与早期的 CSMA/CD (载波侦听多路访问/冲突检测) 机制有关，旨在确保网络中的冲突能够被有效检测。

**为什么在有了 MTU 之后还需要 MSS？** 既然 网络层可以根据 MTU 对过大的数据包进行分片，为什么 TCP 层还需要一个 MSS 呢？

主要原因是为了**尽可能避免在网络层进行分片**，从而提高传输效率和可靠性。

**举例：**

假设没有MSS，在应用层共有1w4字节的数据需要传输，向下经过传输层传到网络层后，网络层收到该数据包（TCP头部+IP头部+应用层数据共14040字节），发现超过了MTU的大小，就将数据包进行分片（网络层分片**效率低下**），分成10片，然后传输，如果其中任意一个分片丢失了，就会将整个数据包全部重传。

在发送端：如果有MSS，在传输层就会将1W4字节的数据，分成10个TCP段，并给这十个段都加一个TCP头部，之后将这十个段向下传给网络层，此时网络层收到数据包（MSS令其最大1500字节）之后，不需要进行分片，加上IP头部后发给数据链路层，每个包**独立传输**。

在接收端：网络层收到十个数据包之后，对每个数据包独立检查错误，解封装后变为TCP段发给传输层，传输层利用TCP头部的**序列号**将这些段**按正确的顺序重新组装**成原始的应用程序数据流。如果有段丢失，TCP会请求重传那个特定的段。组装完成后将完整的数据上传给应用层。

- **IP 分片的效率问题**：IP 层分片对网络是透明的，但它存在一个严重缺陷：如果分片后的任何一个小数据包在传输过程中丢失，整个原始数据包就必须全部重传。 这会大大增加网络开销和延迟。
- **MSS 的主动控制**：通过在 TCP 层设置 MSS，发送方在发送数据之前，就会主动将数据分割成小于 MSS 的段。 这样一来，每个 TCP 段封装成 IP 包后，其大小就不会超过 MTU，从而避免了在 IP 层进行分片。
- **TCP 的高效重传机制**：如果某个 TCP 段在传输中丢失，TCP 的可靠传输机制只需要重传丢失的那个小段即可，而不需要重传整个大数据块，这比 IP 分片丢失后的重传效率高得多。

**总结来说**，MTU 是数据链路层的一个物理限制，而 MSS 是 TCP 层为了适应这个限制而进行的一种主动优化策略。 通过 MSS 协商，TCP 协议可以主动将数据分割成合适的大小，以避免低效的 IP 层分片，从而在保证数据可靠性的同时，最大化地提升网络传输的效率。







# 2. 用户之间收发信息的过程

## CS模式下的通信机制

整个过程，发送方不需要知道接受方的端口号和IP地址，只需要知道服务器的端口号和IP地址（域名）即可

全靠服务器转发给接收方

### 发送方（同学A）的视角
```
同学A发送文件时：
- 只知道：微信服务器的地址（如 wechat.qq.com:443）
- 不知道：同学B的IP地址、端口号、甚至B在哪个网络
- 只需要：告诉服务器"我要给用户B发文件"
```

### 服务器的转发机制
```
微信服务器维护的信息：
用户A：IP=203.0.113.10, 端口=12345, 在线状态=在线
用户B：IP=198.51.100.20, 端口=54321, 在线状态=在线
用户C：IP=192.168.1.100, 端口=23456, 在线状态=离线
```

### 完整的转发过程

#### 1. A发送给服务器
```
A → 服务器的数据包：
源IP: A的IP地址
目标IP: 微信服务器IP
应用层数据: {
    from: "用户A",
    to: "用户B", 
    type: "文件",
    content: 文件数据
}
```

#### 2. 服务器处理和转发
```
服务器收到后：
1. 解析：这是A发给B的文件
2. 查表：B当前的连接信息是 198.51.100.20:54321
3. 转发：将文件数据推送给B
```

#### 3. 服务器发送给B
```
服务器 → B的数据包：
源IP: 微信服务器IP
目标IP: B的IP地址
应用层数据: {
    from: "用户A",
    to: "用户B",
    type: "文件", 
    content: 文件数据
}
```

## 关键优势

### 1. 简化客户端逻辑
```
客户端只需要：
- 连接到服务器
- 发送"给谁发什么"
- 不用管对方在哪里、怎么到达
```

### 2. 解决网络复杂性
```
服务器处理：
- NAT穿透问题
- 用户离线消息存储
- 跨网络路由
- 负载均衡
```

### 3. 实际例子对比

**微信聊天（CS模式）**：
```
你发消息 → 微信服务器 → 对方收到
你不需要知道对方的IP地址
```

**直接P2P聊天**：
```
你发消息 → 直接到对方
但你必须先知道对方的IP:端口
```

## 这就解释了为什么

1. **微信可以给离线用户发消息**：服务器存储转发
2. **不需要知道对方网络信息**：服务器负责寻址
3. **可以跨不同网络通信**：服务器作为中继
4. **群聊很容易实现**：服务器向多个用户转发

**CS模式下，客户端之间不直接通信，完全依靠服务器的"邮局"功能进行消息转发**。这大大简化了客户端的复杂度，但代价是对服务器的完全依赖。



# 3. 获取目标IP地址的方法

在网络数据发送过程中，网络层本身并不主动“发现”目标IP地址，而是从更高层（通常是应用层或传输层）接收这个地址。以下是网络通信中获取目标IP地址的几种常见方法：

### 1. 域名系统 (DNS) 解析

这是最常见的方法，尤其是在访问网站或连接到远程服务器时。整个过程通常如下：

- **用户输入域名**: 用户在浏览器中输入一个网址，例如 `www.google.com`。这个域名对人类友好，但计算机网络需要IP地址来进行通信。
- **发起DNS查询**: 用户的操作系统会将这个域名发送给一个DNS解析器（通常由互联网服务提供商ISP提供）。
- **解析过程**: DNS解析器会查询一系列的DNS服务器（根服务器、顶级域服务器和权威名称服务器），以找到与该域名对应的IP地址。
- **返回IP地址**: 权威DNS服务器最终会将IP地址（例如 `172.217.160.100`）返回给用户的计算机。
- **向下层传递**: 应用程序（如浏览器）获得IP地址后，在准备发送数据时，会将此IP地址连同数据一起传递给传输层，再由传输层传递给网络层。 网络层随后将这个IP地址放入IP数据包的目标地址字段中。

### 2. 静态配置或直接输入

在某些情况下，IP地址是预先知道的，不需要通过DNS解析：

- **直接输入IP**: 用户可以直接在应用程序中输入数字IP地址来代替域名。
- **配置文件**: 应用程序或操作系统可能有一个配置文件，其中静态地指定了要连接的目标服务器的IP地址。这在企业内部网络或特定软件中很常见。

### 3. 从应用程序和服务中获取

许多应用程序在内部处理IP地址的获取过程：

- **API调用**: 程序员在编写网络应用程序时，会使用套接字（Socket）API。在建立连接（如使用 `connect()` 函数）或发送数据包（如使用 `sendto()` 函数）时，目标IP地址会作为一个参数明确地提供给操作系统内核中的网络协议栈。
- **服务发现**: 在复杂的分布式系统中，服务可能会向一个中心目录注册自己的IP地址，其他服务在需要通信时会从该目录查询IP地址。

### 需要澄清的概念：ARP协议

地址解析协议（ARP）经常被提及，但它的作用**不是**获取目标IP地址。ARP的功能恰恰相反：当网络层已经知道了一个IP地址，并且需要将数据包发送到同一局域网内的该IP地址时，它会使用ARP来查询与该IP地址对应的物理硬件地址（MAC地址）。 如果目标IP地址不在同一局域网内，网络层则会使用ARP来查找下一跳路由器（网关）的MAC地址。

总结来说，网络层在发送数据包之前，必须从上层协议（如TCP或UDP）获得明确的目标IP地址。而这个IP地址最常见的来源是通过DNS将用户友好的域名转换而来，或是由用户或应用程序直接提供。